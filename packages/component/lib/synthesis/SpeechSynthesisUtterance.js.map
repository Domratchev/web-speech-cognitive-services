{"version":3,"sources":["../../src/synthesis/SpeechSynthesisUtterance.js"],"names":["asyncDecodeAudioData","audioContext","arrayBuffer","Promise","resolve","reject","promise","decodeAudioData","then","playDecoded","audioBuffer","source","audioContextClosed","EventAsPromise","sourceEnded","unsubscribe","state","target","eventListener","buffer","onended","connect","destination","start","race","upcoming","text","_lang","_pitch","_rate","_voice","_volume","_isAboutToPlay","onboundary","onend","onerror","onmark","onpause","onresume","onstart","arrayBufferPromise","accessToken","lang","window","navigator","language","outputFormat","pitch","rate","voice","voiceURI","undefined","volume","region","createBufferSource","emit","_playingSource","error","type","stop","value","DOMEventEmitter"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA,SAASA,oBAAT,CAA8BC,YAA9B,EAA4CC,WAA5C,EAAyD;AACvD,SAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAMC,OAAO,GAAGL,YAAY,CAACM,eAAb,CAA6BL,WAA7B,EAA0CE,OAA1C,EAAmDC,MAAnD,CAAhB,CADsC,CAGtC;;AACAC,IAAAA,OAAO,IAAI,OAAOA,OAAO,CAACE,IAAf,KAAwB,UAAnC,IAAiDJ,OAAO,CAACE,OAAD,CAAxD;AACD,GALM,CAAP;AAMD;;AAED,SAASG,WAAT,CAAqBR,YAArB,EAAmCS,WAAnC,EAAgDC,MAAhD,EAAwD;AACtD,SAAO,IAAIR,OAAJ;AAAA;AAAA;AAAA;AAAA;AAAA,8BAAY,iBAAOC,OAAP,EAAgBC,MAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AACXO,cAAAA,kBADW,GACU,IAAIC,uBAAJ,EADV;AAEXC,cAAAA,WAFW,GAEG,IAAID,uBAAJ,EAFH;AAGXE,cAAAA,WAHW,GAGG,6BAClBd,YADkB,EAElB,aAFkB,EAGlB;AAAA,oBAAae,KAAb,SAAGC,MAAH,CAAaD,KAAb;AAAA,uBACEA,KAAK,KAAK,QAAV,IAAsBJ,kBAAkB,CAACM,aAAnB,EADxB;AAAA,eAHkB,CAHH;AAAA;AAWfP,cAAAA,MAAM,CAACQ,MAAP,GAAgBT,WAAhB,CAXe,CAYf;;AACAC,cAAAA,MAAM,CAACS,OAAP,GAAiBN,WAAW,CAACI,aAA7B;AAEAP,cAAAA,MAAM,CAACU,OAAP,CAAepB,YAAY,CAACqB,WAA5B;AACAX,cAAAA,MAAM,CAACY,KAAP,CAAa,CAAb;AAhBe;AAAA,qBAkBTpB,OAAO,CAACqB,IAAR,CAAa,CACjBZ,kBAAkB,CAACa,QAAnB,EADiB,EAEjBX,WAAW,CAACW,QAAZ,EAFiB,CAAb,CAlBS;;AAAA;AAuBfrB,cAAAA,OAAO;AAvBQ;AAAA;;AAAA;AAAA;AAAA;AAyBfC,cAAAA,MAAM,aAAN;;AAzBe;AAAA;AA2BfU,cAAAA,WAAW;AA3BI;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAZ;;AAAA;AAAA;AAAA;AAAA,MAAP;AA8BD;;;;;;;AAGC,oBAAYW,IAAZ,EAAkB;AAAA;;AAAA;AAChB,8GAAM,CAAC,UAAD,EAAa,KAAb,EAAoB,OAApB,EAA6B,MAA7B,EAAqC,OAArC,EAA8C,QAA9C,EAAwD,OAAxD,CAAN;AAEA,UAAKC,KAAL,GAAa,IAAb;AACA,UAAKC,MAAL,GAAc,CAAd;AACA,UAAKC,KAAL,GAAa,CAAb;AACA,UAAKC,MAAL,GAAc,IAAd;AACA,UAAKC,OAAL,GAAe,CAAf;AACA,UAAKC,cAAL,GAAsB,KAAtB;AAEA,UAAKN,IAAL,GAAYA,IAAZ;AAEA,UAAKO,UAAL,GAAkB,IAAlB;AACA,UAAKC,KAAL,GAAa,IAAb;AACA,UAAKC,OAAL,GAAe,IAAf;AACA,UAAKC,MAAL,GAAc,IAAd;AACA,UAAKC,OAAL,GAAe,IAAf;AACA,UAAKC,QAAL,GAAgB,IAAhB;AACA,UAAKC,OAAL,GAAe,IAAf;AAlBgB;AAmBjB;;;;8BAqCS;AACR,WAAKC,kBAAL,GAA0B,8BAAgB;AACxCC,QAAAA,WAAW,EAAE,KAAKA,WADsB;AAExCC,QAAAA,IAAI,EAAE,KAAKA,IAAL,IAAaC,MAAM,CAACC,SAAP,CAAiBC,QAFI;AAGxCC,QAAAA,YAAY,EAAE,KAAKA,YAHqB;AAIxCC,QAAAA,KAAK,EAAE,KAAKA,KAJ4B;AAKxCC,QAAAA,IAAI,EAAE,KAAKA,IAL6B;AAMxCtB,QAAAA,IAAI,EAAE,KAAKA,IAN6B;AAOxCuB,QAAAA,KAAK,EAAG,KAAKA,KAAL,IAAc,KAAKA,KAAL,CAAWC,QAA1B,IAAuCC,SAPN;AAQxCC,QAAAA,MAAM,EAAE,KAAKA,MAR2B;AASxCC,QAAAA,MAAM,EAAE,KAAKA;AAT2B,OAAhB,CAA1B;AAWD;;;;;;kDAEUpD,Y;;;;;;;AAEP,qBAAK+B,cAAL,GAAsB,IAAtB,C,CAEA;;AACMrB,gBAAAA,M,GAASV,YAAY,CAACqD,kBAAb,E;+BACWtD,oB;+BACxBC,Y;;uBACM,KAAKuC,kB;;;;;;;;AAFP9B,gBAAAA,W;AAKN,qBAAK6C,IAAL,CAAU,OAAV;AACA,qBAAKC,cAAL,GAAsB7C,MAAtB;;qBAEI,KAAKqB,c;;;;;AACP,qBAAKA,cAAL,GAAsB,KAAtB;;uBACMvB,WAAW,CAACR,YAAD,EAAeS,WAAf,EAA4BC,MAA5B,C;;;AAGnB,qBAAK6C,cAAL,GAAsB,IAAtB;AACA,qBAAKD,IAAL,CAAU,KAAV;;;;;;;AAEA,qBAAKA,IAAL,CAAU,OAAV,EAAmB;AAAEE,kBAAAA,KAAK,cAAP;AAASC,kBAAAA,IAAI,EAAE;AAAf,iBAAnB;;;;;;;;;;;;;;;;;2BAMG;AACL,WAAK1B,cAAL,GAAsB,KAAtB;AAEA,WAAKwB,cAAL,IAAuB,KAAKA,cAAL,CAAoBG,IAApB,EAAvB;AACD;;;wBAjFU;AACT,aAAO,KAAKhC,KAAZ;AACD,K;sBACQiC,K,EAAO;AACd,WAAKjC,KAAL,GAAaiC,KAAb;AACD;;;wBAEW;AACV,aAAO,KAAKhC,MAAZ;AACD,K;sBACSgC,K,EAAO;AACf,WAAKhC,MAAL,GAAcgC,KAAd;AACD;;;wBAEU;AACT,aAAO,KAAK/B,KAAZ;AACD,K;sBACQ+B,K,EAAO;AACd,WAAK/B,KAAL,GAAa+B,KAAb;AACD;;;wBAEW;AACV,aAAO,KAAK9B,MAAZ;AACD,K;sBACS8B,K,EAAO;AACf,WAAK9B,MAAL,GAAc8B,KAAd;AACD;;;wBAEY;AACX,aAAO,KAAK7B,OAAZ;AACD,K;sBACU6B,K,EAAO;AAChB,WAAK7B,OAAL,GAAe6B,KAAf;AACD;;;EAvD0BC,wB","sourcesContent":["import DOMEventEmitter from \"../util/domEventEmitter\";\nimport EventAsPromise from \"event-as-promise\";\nimport fetchSpeechData from \"./fetchSpeechData\";\nimport subscribeEvent from \"./subscribeEvent\";\n\nfunction asyncDecodeAudioData(audioContext, arrayBuffer) {\n  return new Promise((resolve, reject) => {\n    const promise = audioContext.decodeAudioData(arrayBuffer, resolve, reject);\n\n    // Newer implementation of \"decodeAudioData\" will return a Promise\n    promise && typeof promise.then === \"function\" && resolve(promise);\n  });\n}\n\nfunction playDecoded(audioContext, audioBuffer, source) {\n  return new Promise(async (resolve, reject) => {\n    const audioContextClosed = new EventAsPromise();\n    const sourceEnded = new EventAsPromise();\n    const unsubscribe = subscribeEvent(\n      audioContext,\n      \"statechange\",\n      ({ target: { state } }) =>\n        state === \"closed\" && audioContextClosed.eventListener()\n    );\n\n    try {\n      source.buffer = audioBuffer;\n      // \"ended\" may not fire if the underlying AudioContext is closed prematurely\n      source.onended = sourceEnded.eventListener;\n\n      source.connect(audioContext.destination);\n      source.start(0);\n\n      await Promise.race([\n        audioContextClosed.upcoming(),\n        sourceEnded.upcoming()\n      ]);\n\n      resolve();\n    } catch (err) {\n      reject(err);\n    } finally {\n      unsubscribe();\n    }\n  });\n}\n\nexport default class extends DOMEventEmitter {\n  constructor(text) {\n    super([\"boundary\", \"end\", \"error\", \"mark\", \"pause\", \"resume\", \"start\"]);\n\n    this._lang = null;\n    this._pitch = 1;\n    this._rate = 1;\n    this._voice = null;\n    this._volume = 1;\n    this._isAboutToPlay = false;\n\n    this.text = text;\n\n    this.onboundary = null;\n    this.onend = null;\n    this.onerror = null;\n    this.onmark = null;\n    this.onpause = null;\n    this.onresume = null;\n    this.onstart = null;\n  }\n\n  get lang() {\n    return this._lang;\n  }\n  set lang(value) {\n    this._lang = value;\n  }\n\n  get pitch() {\n    return this._pitch;\n  }\n  set pitch(value) {\n    this._pitch = value;\n  }\n\n  get rate() {\n    return this._rate;\n  }\n  set rate(value) {\n    this._rate = value;\n  }\n\n  get voice() {\n    return this._voice;\n  }\n  set voice(value) {\n    this._voice = value;\n  }\n\n  get volume() {\n    return this._volume;\n  }\n  set volume(value) {\n    this._volume = value;\n  }\n\n  preload() {\n    this.arrayBufferPromise = fetchSpeechData({\n      accessToken: this.accessToken,\n      lang: this.lang || window.navigator.language,\n      outputFormat: this.outputFormat,\n      pitch: this.pitch,\n      rate: this.rate,\n      text: this.text,\n      voice: (this.voice && this.voice.voiceURI) || undefined,\n      volume: this.volume,\n      region: this.region\n    });\n  }\n\n  async play(audioContext) {\n    try {\n      this._isAboutToPlay = true;\n\n      // HACK: iOS requires bufferSourceNode to be constructed before decoding data\n      const source = audioContext.createBufferSource();\n      const audioBuffer = await asyncDecodeAudioData(\n        audioContext,\n        await this.arrayBufferPromise\n      );\n\n      this.emit(\"start\");\n      this._playingSource = source;\n\n      if (this._isAboutToPlay) {\n        this._isAboutToPlay = false;\n        await playDecoded(audioContext, audioBuffer, source);\n      }\n\n      this._playingSource = null;\n      this.emit(\"end\");\n    } catch (error) {\n      this.emit(\"error\", { error, type: \"error\" });\n\n      throw error;\n    }\n  }\n\n  stop() {\n    this._isAboutToPlay = false;\n\n    this._playingSource && this._playingSource.stop();\n  }\n}\n"],"file":"SpeechSynthesisUtterance.js"}