{"version":3,"sources":["../../src/synthesis/SpeechSynthesisUtterance.js"],"names":["asyncDecodeAudioData","audioContext","arrayBuffer","resolve","reject","promise","decodeAudioData","then","playDecoded","audioBuffer","source","audioContextClosed","EventAsPromise","sourceEnded","unsubscribe","state","target","eventListener","buffer","onended","connect","destination","start","race","upcoming","text","_lang","_pitch","_rate","_voice","_volume","onboundary","onend","onerror","onmark","onpause","onresume","onstart","arrayBufferPromise","accessToken","lang","window","navigator","language","outputFormat","pitch","rate","voice","voiceURI","undefined","volume","createBufferSource","emit","_playingSource","error","type","stop","value","DOMEventEmitter"],"mappings":"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","file":"SpeechSynthesisUtterance.js","sourcesContent":["import DOMEventEmitter from '../util/domEventEmitter';\nimport EventAsPromise from 'event-as-promise';\nimport fetchSpeechData from './fetchSpeechData';\nimport subscribeEvent from './subscribeEvent';\n\nfunction asyncDecodeAudioData(audioContext, arrayBuffer) {\n  return new Promise((resolve, reject) => {\n    const promise = audioContext.decodeAudioData(arrayBuffer, resolve, reject);\n\n    // Newer implementation of \"decodeAudioData\" will return a Promise\n    promise && typeof promise.then === 'function' && resolve(promise);\n  });\n}\n\nfunction playDecoded(audioContext, audioBuffer, source) {\n  return new Promise(async (resolve, reject) => {\n    const audioContextClosed = new EventAsPromise();\n    const sourceEnded = new EventAsPromise();\n    const unsubscribe = subscribeEvent(audioContext, 'statechange', ({ target: { state } }) => state === 'closed' && audioContextClosed.eventListener());\n\n    try {\n      source.buffer = audioBuffer;\n      // \"ended\" may not fire if the underlying AudioContext is closed prematurely\n      source.onended = sourceEnded.eventListener;\n\n      source.connect(audioContext.destination);\n      source.start(0);\n\n      await Promise.race([\n        audioContextClosed.upcoming(),\n        sourceEnded.upcoming()\n      ]);\n\n      resolve();\n    } catch (err) {\n      reject(err);\n    } finally {\n      unsubscribe();\n    }\n  });\n}\n\nexport default class extends DOMEventEmitter {\n  constructor(text) {\n    super(['boundary', 'end', 'error', 'mark', 'pause', 'resume', 'start']);\n\n    this._lang = null;\n    this._pitch = 1;\n    this._rate = 1;\n    this._voice = null;\n    this._volume = 1;\n\n    this.text = text;\n\n    this.onboundary = null;\n    this.onend = null;\n    this.onerror = null;\n    this.onmark = null;\n    this.onpause = null;\n    this.onresume = null;\n    this.onstart = null;\n  }\n\n  get lang() { return this._lang; }\n  set lang(value) { this._lang = value; }\n\n  get pitch() { return this._pitch; }\n  set pitch(value) { this._pitch = value; }\n\n  get rate() { return this._rate; }\n  set rate(value) { this._rate = value; }\n\n  get voice() { return this._voice; }\n  set voice(value) { this._voice = value; }\n\n  get volume() { return this._volume; }\n  set volume(value) { this._volume = value; }\n\n  async preload() {\n    this.arrayBufferPromise = fetchSpeechData({\n      accessToken: this.accessToken,\n      lang: this.lang || window.navigator.language,\n      outputFormat: this.outputFormat,\n      pitch: this.pitch,\n      rate: this.rate,\n      text: this.text,\n      voice: this.voice && this.voice.voiceURI || undefined,\n      volume: this.volume\n    });\n\n    await this.arrayBufferPromise;\n  }\n\n  async play(audioContext) {\n    try {\n      // HACK: iOS requires bufferSourceNode to be constructed before decoding data\n      const source = audioContext.createBufferSource();\n      const audioBuffer = await asyncDecodeAudioData(audioContext, await this.arrayBufferPromise);\n\n      this.emit('start');\n      this._playingSource = source;\n\n      await playDecoded(audioContext, audioBuffer, source);\n\n      this._playingSource = null;\n      this.emit('end');\n    } catch (error) {\n      this.emit('error', { error, type: 'error' });\n\n      throw error;\n    }\n  }\n\n  stop() {\n    this._playingSource && this._playingSource.stop();\n  }\n}\n"]}