{"version":3,"sources":["../../src/recognition/SpeechRecognition.js"],"names":["buildSpeechResult","transcript","confidence","isFinal","result","results","type","_lang","readyState","onaudiostart","onaudioend","onend","onerror","onnomatch","onresult","onsoundstart","onsoundend","onspeechstart","onspeechend","onstart","createRecognizer","lang","navigator","language","mode","CognitiveSpeech","RecognitionMode","Interactive","osPlatform","window","userAgent","osName","appName","osVersion","appVersion","deviceManufacturer","deviceModel","deviceVersion","config","RecognizerConfig","SpeechConfig","Context","OS","Device","SpeechResultFormat","Detailed","fetchToken","sink","Sink","console","error","Reject","then","Resolve","Promise","err","message","CreateRecognizer","CognitiveTokenAuthentication","recognizer","AudioSource","TurnOff","_aborted","name","event","listener","call","Error","toPromise","eventListener","promises","speechContext","grammars","createSpeechContext","Recognize","JSON","stringify","recognitionTriggered","race","listeningStarted","recognitionEnded","Name","Status","RecognitionCompletionStatus","AudioSourceError","emit","connectingToService","recognitionStarted","ConnectError","getSpeechHypothesisPromise","speechEndDetected","speechHypothesis","gotFirstHypothesis","Result","Text","speechDetailedPhrase","recognitionResult","RecognitionStatus","Success","NBest","Display","Confidence","NoMatch","InitialSilenceTimeout","_grammars","nextGrammars","SpeechGrammarList","nextLang","nextContinuous","nextInterimResults","nextMaxAlternatives","nextServiceURI","events","ConnectingToServiceEvent","EventAsPromise","ListeningStartedEvent","RecognitionEndedEvent","RecognitionStartedEvent","RecognitionTriggeredEvent","SpeechDetailedPhraseEvent","SpeechEndDetectedEvent","SpeechHypothesisEvent","SpeechSimplePhraseEvent","SpeechStartDetectedEvent","upcoming","speechSimplePhrase","speechStartDetected","eventAsPromise","warn"],"mappings":"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","sourcesContent":["import * as CognitiveSpeech from 'microsoft-speech-browser-sdk';\nimport EventAsPromise from 'event-as-promise';\nimport memoize from 'memoize-one';\n\nimport SpeechGrammarList from './SpeechGrammarList';\n\nfunction buildSpeechResult(transcript, confidence, isFinal) {\n  const result = [{ confidence, transcript }];\n\n  result.isFinal = isFinal;\n\n  return { results: [result], type: 'result' };\n}\n\nexport default class {\n  constructor() {\n    this._lang = '';\n\n    this.readyState = 0;\n\n    this.onaudiostart = null;\n    this.onaudioend = null;\n    this.onend = null;\n    this.onerror = null;\n    this.onnomatch = null;\n    this.onresult = null;\n    this.onsoundstart = null;\n    this.onsoundend = null;\n    this.onspeechstart = null;\n    this.onspeechend = null;\n    this.onstart = null;\n\n    this.createRecognizer = memoize((\n      lang = navigator.language,\n      mode = CognitiveSpeech.RecognitionMode.Interactive,\n      osPlatform = window.navigator.userAgent,\n      osName = window.navigator.appName,\n      osVersion = window.navigator.appVersion,\n      deviceManufacturer = 'microsoft-speech-browser-sdk',\n      deviceModel = 'web-speech-cognitive-services',\n      deviceVersion = VERSION\n    ) => {\n      const config = new CognitiveSpeech.RecognizerConfig(\n        new CognitiveSpeech.SpeechConfig(\n          new CognitiveSpeech.Context(\n            new CognitiveSpeech.OS(\n              osPlatform,\n              osName,\n              osVersion\n            ),\n            new CognitiveSpeech.Device(\n              deviceManufacturer,\n              deviceModel,\n              deviceVersion\n            )\n          )\n        ),\n        mode,\n        lang,\n        CognitiveSpeech.SpeechResultFormat.Detailed\n      );\n\n      const fetchToken = () => {\n        try {\n          const sink = new CognitiveSpeech.Sink();\n\n          if (!this.fetchToken) {\n            console.error('SpeechRecognition: fetchToken must be set');\n\n            return sink.Reject('fetchToken must be set');\n          } else if (typeof this.fetchToken !== 'function') {\n            console.error('SpeechRecognition: fetchToken must be a function that returns a Promise and it will resolve to a string-based token');\n\n            return sink.Reject('fetchToken must be a function that returns a Promise and it will resolve to a string-based token');\n          }\n\n          this.fetchToken().then(sink.Resolve, sink.Reject);\n\n          return new CognitiveSpeech.Promise(sink);\n        } catch (err) {\n          sink.Reject(err.message);\n        }\n      };\n\n      return CognitiveSpeech.CreateRecognizer(config, new CognitiveSpeech.CognitiveTokenAuthentication(fetchToken, fetchToken));\n    });\n  }\n\n  get grammars() { return this._grammars; }\n  set grammars(nextGrammars) {\n    if (nextGrammars && !(nextGrammars instanceof SpeechGrammarList)) {\n      throw new Error('must be instance of SpeechGrammarList from \"web-speech-cognitive-services\"');\n    }\n\n    this._grammars = nextGrammars;\n  }\n\n  get lang() { return this._lang; }\n  set lang(nextLang) { this._lang = nextLang; }\n\n  get continuous() { return false; }\n  set continuous(nextContinuous) { throw new Error('not supported'); }\n\n  get interimResults() { return true; }\n  set interimResults(nextInterimResults) {\n    if (!nextInterimResults) {\n      throw new Error('not supported');\n    }\n  }\n\n  get maxAlternatives() { return 1; }\n  set maxAlternatives(nextMaxAlternatives) { throw new Error('not supported'); }\n\n  get serviceURI() { return null; }\n  set serviceURI(nextServiceURI) { throw new Error('not supported'); }\n\n  abort() {\n    // TODO: Should redesign how to stop a recognition session\n    //       After abort is called, we should not saw it is a \"success\", \"silent\", or \"no match\"\n    const { AudioSource } = this.recognizer || {};\n\n    AudioSource && AudioSource.TurnOff();\n\n    this._aborted = true;\n  }\n\n  emit(name, event) {\n    const listener = this[`on${ name }`];\n\n    listener && listener.call(this, { ...event, type: name });\n  }\n\n  stop() {\n    // TODO: Support stop\n    throw new Error('not supported');\n  }\n\n  async start() {\n    const recognizer = this.recognizer = this.createRecognizer(\n      this.lang,\n      this.osPlatform || window.navigator.userAgent,\n      this.osName || window.navigator.appName,\n      this.osVersion || window.navigator.appVersion,\n      this.deviceManufacturer || 'web-speech-cognitive-services',\n      this.deviceModel || 'web-speech-cognitive-services',\n      this.deviceVersion || VERSION\n    );\n\n    const { eventListener, ...promises } = toPromise();\n\n    const speechContext = this.grammars && this.grammars.createSpeechContext();\n\n    recognizer.Recognize(eventListener, speechContext && JSON.stringify(speechContext));\n    this._aborted = false;\n\n    await promises.recognitionTriggered;\n\n    let error;\n\n    const listeningStarted = await Promise.race([\n      promises.listeningStarted,\n      promises.recognitionEnded\n    ]);\n\n    if (listeningStarted.Name === 'RecognitionEndedEvent') {\n      // Possibly not authorized to use microphone\n      if (listeningStarted.Status === CognitiveSpeech.RecognitionCompletionStatus.AudioSourceError) {\n        error = 'not-allowed';\n      } else {\n        error = CognitiveSpeech.RecognitionCompletionStatus[listeningStarted.Status];\n      }\n    } else {\n      this.emit('start');\n\n      await promises.connectingToService;\n\n      const recognitionStarted = await Promise.race([\n        promises.recognitionStarted,\n        promises.recognitionEnded\n      ]);\n\n      this.emit('audiostart');\n\n      if (recognitionStarted.Name === 'RecognitionEndedEvent') {\n        // Possibly network error\n        if (recognitionStarted.Status === CognitiveSpeech.RecognitionCompletionStatus.ConnectError) {\n          error = 'network';\n        } else {\n          error = CognitiveSpeech.RecognitionCompletionStatus[recognitionStarted.Status];\n        }\n      } else {\n        let gotFirstHypothesis;\n\n        for (;;) {\n          const speechHypothesis = await Promise.race([\n            promises.getSpeechHypothesisPromise(),\n            promises.speechEndDetected\n          ]);\n\n          if (speechHypothesis.Name === 'SpeechEndDetectedEvent') {\n            break;\n          }\n\n          if (!gotFirstHypothesis) {\n            gotFirstHypothesis = true;\n            this.emit('soundstart');\n            this.emit('speechstart');\n          }\n\n          this.emit('result', buildSpeechResult(speechHypothesis.Result.Text, .5, false));\n        }\n\n        if (gotFirstHypothesis) {\n          this.emit('speechend');\n          this.emit('soundend');\n        }\n      }\n\n      this.emit('audioend');\n\n      if (this._aborted) {\n        error = 'aborted';\n\n        await promises.recognitionEnded;\n      } else {\n        const speechDetailedPhrase = await Promise.race([\n          promises.speechDetailedPhrase,\n          promises.recognitionEnded\n        ]);\n\n        if (speechDetailedPhrase.Name !== 'RecognitionEndedEvent') {\n          const recognitionResult = CognitiveSpeech.RecognitionStatus[speechDetailedPhrase.Result.RecognitionStatus];\n\n          if (recognitionResult === CognitiveSpeech.RecognitionStatus.Success) {\n            this.emit('result', buildSpeechResult(speechDetailedPhrase.Result.NBest[0].Display, speechDetailedPhrase.Result.NBest[0].Confidence, true));\n          } else if (recognitionResult !== CognitiveSpeech.RecognitionStatus.NoMatch) {\n            // Possibly silent or muted\n            if (recognitionResult === CognitiveSpeech.RecognitionStatus.InitialSilenceTimeout) {\n              error = 'no-speech';\n            } else {\n              error = speechDetailedPhrase.Result.RecognitionStatus;\n            }\n          }\n\n          await promises.recognitionEnded;\n        }\n      }\n    }\n\n    error && this.emit('error', { error });\n    this.emit('end');\n  }\n}\n\nfunction toPromise() {\n  const events = {\n    ConnectingToServiceEvent: new EventAsPromise(),\n    ListeningStartedEvent: new EventAsPromise(),\n    RecognitionEndedEvent: new EventAsPromise(),\n    RecognitionStartedEvent: new EventAsPromise(),\n    RecognitionTriggeredEvent: new EventAsPromise(),\n    SpeechDetailedPhraseEvent: new EventAsPromise(),\n    SpeechEndDetectedEvent: new EventAsPromise(),\n    SpeechHypothesisEvent: new EventAsPromise(),\n    SpeechSimplePhraseEvent: new EventAsPromise(),\n    SpeechStartDetectedEvent: new EventAsPromise()\n  };\n\n  return {\n    connectingToService: events.ConnectingToServiceEvent.upcoming(),\n    listeningStarted: events.ListeningStartedEvent.upcoming(),\n    recognitionEnded: events.RecognitionEndedEvent.upcoming(),\n    recognitionStarted: events.RecognitionStartedEvent.upcoming(),\n    recognitionTriggered: events.RecognitionTriggeredEvent.upcoming(),\n    speechDetailedPhrase: events.SpeechDetailedPhraseEvent.upcoming(),\n    speechEndDetected: events.SpeechEndDetectedEvent.upcoming(),\n    getSpeechHypothesisPromise: () => events.SpeechHypothesisEvent.upcoming(),\n    speechSimplePhrase: events.SpeechSimplePhraseEvent.upcoming(),\n    speechStartDetected: events.SpeechStartDetectedEvent.upcoming(),\n    eventListener: event => {\n      const { Name: name } = event;\n      const eventAsPromise = events[name];\n\n      if (eventAsPromise) {\n        eventAsPromise.eventListener.call(null, event);\n      } else {\n        console.warn(`Unexpected event \\\"${ name }\\\" from Cognitive Services, please file a bug to https://github.com/compulim/web-speech-cognitive-services`);\n      }\n    }\n  };\n}\n"],"file":"SpeechRecognition.js"}